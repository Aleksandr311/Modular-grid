//Есть восемь основных типов данных в JavaScript:

//Строка - string
//Число - number (ограничено)
//bigint для целых чисел произвольной длины(не ограничено)
//Булевый (логический) тип - boolean для true/false
//Объекты - object
//Символ - symbol
//Значение null - 
//Значение undefined - 

//Строка - string Должна быть заключена в кавычки (двойные или одинарные или обратные)
let message = "Hello";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные  ${str2}`;
//Итого три типа кавычек: "", '', ``.
//Первые два не отличаются в js, но есть нюансы или нет

//Обратные кавычки:
//Расширенная функциональность позволяет встраивать встраивать выражения в строку
// заключая их в ${...}
let girl = 'Ann'
let boy = "Ben"
alert(`Мальчик по имени ${boy} Говорит "Hello", девочка ${girl} отвечает 'Hi', 
а сколько времени интересуется ${boy}? "Звезды говорят ${7+17-34*2+63}"
 ответила ${girl} и нырнула в лужу`);
//Думаю что удобно для часто повторяемых фраз, выражений и для переноса строк итд

//спец. символы:
let prise = "Список:\n *очки\n *телефон\n *часы"
console.log(prise);
//с помощью обратного слеша можно экранировать символы
// \\- обратный слеш
// \" - доп кавычки итд
console.log('I\'m a doctor')

//длина строки
let len = "Hello.";
console.log(len.length);//длина строки
console.log(len[2]);//получаем третий символ
console.log(len[len.length-2]);//второй символ с конца
//Также можно перебрать строку посимвольно, используя for..of:
for (let char of "Hello") {
    console.log(char); // H,e,l,l,o
  };
let str = 'Hi';
str = 'h' + str[1]; // заменяем строку
console.log(str ); // hi

//Методы toLowerCase() и toUpperCase() меняют регистр символов:
console.log( 'Какая ТО строка'.toUpperCase() ); // КАКАЯ ТО СТРОКА
console.log( 'Какая ТО строка'.toLowerCase() ); // какая то строка
//Если мы захотим перевести в нижний регистр какой-то конкретный символ:
console.log( 'Какая ТО строка'[7].toLowerCase() ); // 'о'

//Поиск подстроки
let stroka = 'Дети делают дело';
console.log( stroka.indexOf('Де') ); // 0, потому что подстрока 'Widget' найдена в начале
console.log( stroka.indexOf('дети') ); // -1, совпадений нет, поиск чувствителен к регистру
console.log( stroka.indexOf("де") ); // 5, подстрока "де" найдена на позиции 5 
//Необязательный второй аргумент позволяет начать поиск с определённой позиции.
//Например, первое вхождение "де" — на позиции 5. Для того, чтобы найти следующее,
//начнём поиск с позиции 6:
console.log( stroka.indexOf('де', 6)); // 12
//Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле.
//Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:
let target = "де";
let pos = -1;
while ((pos = stroka.indexOf(target, pos + 1)) != -1) {
  console.log( pos );//5, 12
}//while - создает цикл

//includes, startsWith, endsWith. Рассмотрим includes
//Более современный метод stroka.includes('Дети делают дело') возвращает true, если в строке stroka
//есть подстрока "де", либо false, если нет.
//Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, 
//но позиция не нужна:
console.log( 'Дети делают дело'.includes('де') ); // true
console.log( 'Дети делают дело'.includes('ди') ); // false
//Необязательный второй аргумент stroka.includes позволяет начать поиск с определённой позиции:
console.log( 'Дети делают дело'.includes('де') ); // true
console.log( 'Дети делают дело'.includes('де', 13) ); // false, поиск начат с позиции 13
//Методы stroka.startsWith и stroka.endsWith проверяют, соответственно, начинается ли и
//заканчивается ли строка определённой строкой:
console.log( 'Дети делают дело'.startsWith('Де') ); // true, 'Де' — начало 'Дети...'
console.log( 'Дети делают дело'.endsWith('ло') ); // true, 'ло' — окончание '...дело'
console.log( 'Дети делают дело'.endsWith('де') ); // false, 'де' — yt окончание '...дело'

//Получение подстроки slice:
//stroka.slice(start[, end]);вопрос с,//Возвращает часть строки от start до (не включая) end.
stroka = 'Изменяем строку';
// 'яем строку', символы от 5 до 14 (не включая 5)
console.log( stroka.slice(5, 14) );
// 'И', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
console.log( stroka.slice(0, 1) );
//Если аргумент end отсутствует, slice возвращает символы до конца строки:
console.log( stroka.slice(2) ); // 'меняем строку', с позиции 2 и до конца
//Также для start/end можно задавать отрицательные значения. Это означает, 
//что позиция определена как заданное количество символов с конца строки:
// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
console.log( stroka.slice(-8, -2) ); // 'м стро'

//Сравнение строк



//Число - number (ограничено(2**53-1) (т. е. 9007199254740991), или меньше,
// чем -(2**53-1) для отрицательных чисел)
let number = 123;
console.log(number);
number = 12.345*8;
console.log(number);//Возвращает number построчно
//числа можно округлять
//Infinity, -Infinity и NaN

//Infinity представляет собой математическую бесконечность ∞. 
//Это особое значение, которое больше любого числа.
//Мы можем получить его в результате деления на ноль:
console.log( 1 / 0 ); // Infinity
//Или задать его явно:
console.log( Infinity ); // Infinity
var a = 3,
    b = Infinity;
console.log(a - a); // 0.
console.log(b - b); // NaN
console.log(Infinity > Infinity);//false
console.log(Infinity > 10**309);//false
//"что угодно, помноженное на Infinity дает Infinity". Не совсем.
//если умножить Infinity на 0 будет NaN:
console.log(Infinity * 0);//NaN
//"и что угодно, деленное на Infinity дает 0." Тоже не всегда:
console.log(Infinity / Infinity);//NaN
//Также Infinity,не равно бесконечности,
//а равно примерно 10**309:
console.log(Infinity == 10**309);//true

//NaN  вычислительная ошибка. 
//Это результат неправильной или неопределённой математической операции, например:
console.log( "Строка" / 2 ); // NaN, такое деление является ошибкой
console.log("22" / 2);//11 Строка 22 преобразуется в число
//Значение NaN «прилипчиво».
//Если где-то в математическом выражении есть NaN, 
//то результатом вычислений с его участием будет NaN
console.log( "не число" / 2 + 5 ); // NaN
//*Математические операции – в JavaScript «безопасны». Мы можем делать что угодно: 
//делить на ноль, обращаться с нечисловыми строками как с числами и т.д.
//Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»).
// В худшем случае мы получим NaN как результат выполнения.

//bigint для целых чисел произвольной длины(не ограничено)
console.log(Infinity*BigInt);//NaN
//Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами
//произвольной длины. Чтобы создать значение типа BigInt, необходимо добавить n в конец 
//числового литерала:
const bigInt = 1234567890123456789012345678901234567890n;//"n" в конце означает - BigInt
//Так как BigInt-числа нужны достаточно редко, мы рассмотрим их в отдельной главе BigInt.

//Булевый (логический) тип - boolean для true/false
//может принимать только два значения: true (истина) и false (ложь)
//Булевые значения также могут быть результатом сравнений:
let compare = 4 > 1;
console.log(compare);//true
let compare1 = 4 < 1;
console.log(compare1);//false
//*Более сложные сравнения через if else?????

//Объекты - object (особенный тип данный)
let obj = {};
console.log(typeof obj);
//Все остальные типы называются «примитивными», потому что их значениями могут быть
//только простые значения (будь то строка, или число, или что-то ещё). 
//В объектах же хранят коллекции данных или более сложные структуры.
//Объекты занимают важное место в языке и требуют особого внимания. 
//Мы разберёмся с ними в главе Объекты после того, как узнаем больше о примитивах.

//Тип symbol (символ) используется для создания уникальных идентификаторов в объектах. 
//Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов

//Null - 'ничего', "пусто", "значение неизвестно"
//Значение «null» Специальное значение null не относится ни к одному из типов.
//Оно формирует отдельный тип, который содержит только значение null:
let age = null;
//В JavaScript null не является «ссылкой на несуществующий объект» или 
//«нулевым указателем», как в некоторых других языках.
//В приведённом выше коде указано, что значение переменной age неизвестно.

//undefined - переменной не присвоено значение
let length; 
console.log(length);//Выведет значение undefined
//мы можем присвоить значение undefined любой переменной
let cat = typeof "Murka";
console.log(cat);//Murka
cat = undefined;
console.log(cat);//undefined
//Но так делать не рекомендуется. Обычно null используется для присвоения переменной
//«пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная
//назначена



//ЗАДАЧА: сначала решаю сам потом смотрю ответ
let name = "Ilya";
console.log( `hello ${1}` ); // hello 1
console.log( `hello ${"name"}` );// hello name 
console.log( `hello ${name}` ); // hello Ilya  ОТВЕТ: все верно

